// Hybrid Memory Types Schema
// Implements storage strategy pattern with generic and structured types

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ============================================================================
// ENUMS
// ============================================================================

enum UserTier {
  free
  premium
}

enum MemoryState {
  SAVED
  DRAFT
  DELETED
}

enum StorageStrategy {
  generic // Data stored in memories.data as JSONB
  structured // Data stored in dedicated table

  @@map("storagestrategy")
}

enum EnrichmentStatus {
  pending
  processing
  completed
  failed
  queued_budget
}

enum ReminderStatus {
  pending
  sent
  cancelled
}

enum LinkType {
  locatedAt // Memory is located at another memory (location)
  summaryOf // Memory summarizes another memory
  hasMedia // Memory has media attachment (another memory)
  related // Generic relationship
  mentions // Memory mentions a person/entity

  @@map("linktype")
}

enum TranscriptStatus {
  none
  partial
  full
  failed
}

enum TranscriptSource {
  captions
  auto
  asr
  manual
  unknown
}

enum LearningStyle {
  VISUAL // Images, dual coding, visual mnemonics
  HANDS_ON // Interactive practice, errorless learning
  THEORETICAL // Elaborative encoding, conceptual understanding
  MIXED // Balanced approach
}

enum SkillLevel {
  BEGINNER // More support, errorless learning, recognition-based
  INTERMEDIATE // Balanced challenge, mixed recall types
  ADVANCED // Free recall, complex elaboration, higher intervals
}

enum PrimaryGoal {
  RETENTION // Optimize for long-term memory retention
  LEARNING // Focus on acquiring new information quickly
  ORGANIZATION // Emphasis on structure, projects, and connections
  HABIT_BUILDING // Consistency, streaks, daily routines
}

enum PreferredPace {
  INTENSIVE // High daily volume, shorter intervals
  MODERATE // Balanced workload, standard intervals
  GRADUAL // Lower volume, extended intervals
}

enum TriggerType {
  TIME // Specific time of day
  LOCATION // Geofence trigger (requires location permission)
  ROUTINE // After/before a routine event (meal, work, sleep)
  CONTEXT // Activity-based (e.g., commute, exercise)
}

enum Frequency {
  DAILY // Every day
  WEEKDAYS // Monday-Friday
  WEEKENDS // Saturday-Sunday
  CUSTOM // Specific days defined in customDays
}

enum CheckInType {
  WEEKLY // Periodic check-in after 7 days
  MONTHLY // Periodic check-in after 30 days
  TRIGGERED // Triggered by performance metrics
}

enum IngestionStatus {
  queued
  ingested
  retry
  failed
  blocked
}

enum SpeechSessionStatus {
  active
  processing
  completed
  failed
  expired
}

// ============================================================================
// USER & AUTH
// ============================================================================

model User {
  id                    String   @id @default(uuid()) @db.Uuid
  email                 String   @unique
  passwordHash          String?  @map("password_hash")
  googleId              String?  @unique @map("google_id")
  provider              String?  @default("local") // 'local' or 'google'
  tier                  String   @default("free")
  roles                 String[] @default(["user"])
  isEnabled             Boolean  @default(true) @map("is_enabled")
  requirePasswordChange Boolean  @default(false) @map("require_password_change")
  createdAt             DateTime @default(now()) @map("created_at")
  updatedAt             DateTime @updatedAt @map("updated_at")

  // Relations
  memories                 Memory[]
  sessions                 Session[]
  reminders                Reminder[]
  usage                    UserUsage?
  stats                    UserStats?
  reminderPreferences      UserReminderPreferences?
  helpViews                UserHelpView[]
  idempotencyKeys          IdempotencyKey[]
  aiCostTracking           AiCostTracking[]
  excludedWords            ExcludedWord[]
  images                   Image[]
  urlPages                 UrlPage[]
  memoryDecks              MemoryDeck[]
  projects                 Project[]
  trainings                Training[]
  trainingDecks            TrainingDeck[]
  twitterPosts             TwitterPost[]
  speechSessions           SpeechSession[]
  userLexicon              UserLexicon[]
  transcriptFeedback       TranscriptFeedback[]
  questions                Question[]
  memoryProfile            UserMemoryProfile?
  adaptiveReviewConfig     AdaptiveReviewConfig?
  implementationIntentions ImplementationIntention[]
  dailyCheckIns            DailyCheckIn[]
  profileCheckIns          ProfileCheckIn[]

  @@map("users")
}

model UserUsage {
  userId                String   @id @map("user_id") @db.Uuid
  memoriesToday         Int      @default(0) @map("memories_today")
  memoriesThisMonth     Int      @default(0) @map("memories_this_month")
  imagesThisMonth       Int      @default(0) @map("images_this_month")
  voiceThisMonth        Int      @default(0) @map("voice_this_month")
  voiceMinutesThisMonth Int      @default(0) @map("voice_minutes_this_month")
  searchesToday         Int      @default(0) @map("searches_today")
  storageBytes          BigInt   @default(0) @map("storage_bytes")
  lastDailyReset        DateTime @default(now()) @map("last_daily_reset")
  lastMonthlyReset      DateTime @default(now()) @map("last_monthly_reset")

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("user_usage")
}

model UserStats {
  id     String @id @default(uuid()) @db.Uuid
  userId String @unique @map("user_id") @db.Uuid

  // Capture streaks
  currentStreakDays Int       @default(0) @map("current_streak_days")
  longestStreakDays Int       @default(0) @map("longest_streak_days")
  lastCaptureDate   DateTime? @map("last_capture_date")

  // Review statistics
  totalReviewsCompleted Int @default(0) @map("total_reviews_completed")
  totalReviewsAgain     Int @default(0) @map("total_reviews_again")
  totalReviewsHard      Int @default(0) @map("total_reviews_hard")
  totalReviewsGood      Int @default(0) @map("total_reviews_good")
  totalReviewsEasy      Int @default(0) @map("total_reviews_easy")

  // Memory statistics
  totalMemoriesCreated Int @default(0) @map("total_memories_created")
  totalLinksCreated    Int @default(0) @map("total_links_created")

  // Sentiment balance
  sentimentPositive Int @default(0) @map("sentiment_positive")
  sentimentNeutral  Int @default(0) @map("sentiment_neutral")
  sentimentNegative Int @default(0) @map("sentiment_negative")

  // Achievements (JSON array of achievement codes)
  achievementsUnlocked Json @default("[]") @map("achievements_unlocked")

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("user_stats")
}

model UserReminderPreferences {
  id     String @id @default(uuid()) @db.Uuid
  userId String @unique @map("user_id") @db.Uuid

  // Reminder intervals in minutes
  firstReminderMinutes  Int @default(3) @map("first_reminder_minutes")
  secondReminderMinutes Int @default(4320) @map("second_reminder_minutes") // 3 days
  thirdReminderMinutes  Int @default(30240) @map("third_reminder_minutes") // 3 weeks

  // Enable/disable reminders
  remindersEnabled Boolean @default(true) @map("reminders_enabled")

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("user_reminder_preferences")
}

model UserHelpView {
  id         String    @id @default(uuid()) @db.Uuid
  userId     String    @map("user_id") @db.Uuid
  pageKey    String    @map("page_key") @db.VarChar(100)
  viewCount  Int       @default(0) @map("view_count")
  lastViewAt DateTime? @map("last_view_at")
  createdAt  DateTime  @default(now()) @map("created_at")
  updatedAt  DateTime  @updatedAt @map("updated_at")

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, pageKey])
  @@index([userId])
  @@map("user_help_views")
}

// ============================================================================
// USER MEMORY & PERSONALIZATION SYSTEM
// ============================================================================

model UserMemoryProfile {
  id     String @id @default(uuid()) @db.Uuid
  userId String @unique @map("user_id") @db.Uuid

  // Onboarding Data
  learningStyle        LearningStyle @map("learning_style")
  skillLevel           SkillLevel    @map("skill_level")
  primaryGoal          PrimaryGoal   @map("primary_goal")
  preferredPace        PreferredPace @map("preferred_pace")
  dailyTimeCommitment  Int           @map("daily_time_commitment") // Minutes per day
  areasOfInterest      String[]      @map("areas_of_interest")
  cognitivePreferences Json?         @map("cognitive_preferences") // Extended preferences

  // Adaptive Performance Tracking
  averageRecallRate     Float    @default(0.0) @map("average_recall_rate") // 0.0-1.0
  averageReviewTime     Int      @default(0) @map("average_review_time") // Avg seconds per review
  optimalReviewInterval Float    @default(1.0) @map("optimal_review_interval") // Base interval multiplier
  preferredReviewTime   String?  @map("preferred_review_time") @db.VarChar(20) // e.g., "morning"
  lastAdaptationUpdate  DateTime @default(now()) @map("last_adaptation_update")

  // Engagement Patterns
  peakActivityHours     Int[] @map("peak_activity_hours") // Hours of day (0-23)
  consecutiveMissedDays Int   @default(0) @map("consecutive_missed_days")
  totalCheckIns         Int   @default(0) @map("total_check_ins")

  // State
  onboardingCompleted Boolean   @default(false) @map("onboarding_completed")
  lastCheckInDate     DateTime? @map("last_check_in_date")

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([userId, onboardingCompleted])
  @@map("user_memory_profiles")
}

model ImplementationIntention {
  id     String @id @default(uuid()) @db.Uuid
  userId String @map("user_id") @db.Uuid

  // If-Then Structure
  triggerType  TriggerType @map("trigger_type")
  triggerValue String      @map("trigger_value") @db.VarChar(255)
  action       String      @db.VarChar(500)
  ifThenPhrase String      @map("if_then_phrase") @db.Text

  // Configuration
  enabled    Boolean   @default(true)
  frequency  Frequency @default(DAILY)
  customDays Int[]     @map("custom_days") // Days of week (0-6) for CUSTOM frequency

  // Tracking & Adaptation
  completionCount Int       @default(0) @map("completion_count")
  missedCount     Int       @default(0) @map("missed_count")
  lastTriggeredAt DateTime? @map("last_triggered_at")
  lastCompletedAt DateTime? @map("last_completed_at")

  // Escalation
  firstReminderMinutes  Int @default(0) @map("first_reminder_minutes")
  secondReminderMinutes Int @default(120) @map("second_reminder_minutes")
  thirdReminderMinutes  Int @default(1440) @map("third_reminder_minutes")

  // State
  isPaused Boolean   @default(false) @map("is_paused")
  pausedAt DateTime? @map("paused_at")

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, enabled])
  @@index([userId, triggerType])
  @@index([lastTriggeredAt])
  @@map("implementation_intentions")
}

model AdaptiveReviewConfig {
  id     String @id @default(uuid()) @db.Uuid
  userId String @unique @map("user_id") @db.Uuid

  // Spaced Repetition Parameters
  initialInterval   Float @default(1.0) @map("initial_interval") // Days
  easeFactorDefault Float @default(2.3) @map("ease_factor_default")
  maxInterval       Int   @default(30) @map("max_interval") // Days
  minEaseFactor     Float @default(1.3) @map("min_ease_factor")

  // Personalized Multipliers (auto-adjusted)
  intervalMultiplier  Float @default(1.0) @map("interval_multiplier") // 0.5-2.0
  difficultyThreshold Float @default(0.8) @map("difficulty_threshold")

  // Review Session Preferences
  maxReviewsPerSession Int     @default(20) @map("max_reviews_per_session")
  preferRecognition    Boolean @default(false) @map("prefer_recognition")
  showContext          Boolean @default(true) @map("show_context")
  enableHapticFeedback Boolean @default(true) @map("enable_haptic_feedback")

  // Adaptive Scheduling Rules
  adaptiveScheduling Boolean @default(true) @map("adaptive_scheduling")
  forgivenessFactor  Float   @default(0.5) @map("forgiveness_factor")

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@map("adaptive_review_configs")
}

model DailyCheckIn {
  id     String @id @default(uuid()) @db.Uuid
  userId String @map("user_id") @db.Uuid

  checkInDate DateTime @map("check_in_date") @db.Date

  // Completion Data
  reviewsDue          Int @default(0) @map("reviews_due")
  reviewsCompleted    Int @default(0) @map("reviews_completed")
  intentionsTriggered Int @default(0) @map("intentions_triggered")
  intentionsCompleted Int @default(0) @map("intentions_completed")

  // Self-Report (optional)
  confidenceLevel  Int? @map("confidence_level") // 1-5 scale
  difficultyLevel  Int? @map("difficulty_level") // 1-5 scale
  timeSpentMinutes Int? @map("time_spent_minutes")

  // Adaptive Insights
  suggestedAdjustment String? @map("suggested_adjustment") @db.VarChar(100)
  userAcknowledged    Boolean @default(false) @map("user_acknowledged")

  createdAt DateTime @default(now()) @map("created_at")

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, checkInDate])
  @@index([userId])
  @@index([checkInDate])
  @@map("daily_check_ins")
}

model ProfileCheckIn {
  id     String @id @default(uuid()) @db.Uuid
  userId String @map("user_id") @db.Uuid

  checkInType   CheckInType @map("check_in_type")
  triggerReason String?     @map("trigger_reason") @db.VarChar(255)

  // Questions Asked (dynamic)
  questions Json

  // Resulting Profile Changes
  profileUpdatesBefore Json @map("profile_updates_before")
  profileUpdatesAfter  Json @map("profile_updates_after")

  createdAt DateTime @default(now()) @map("created_at")

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([checkInType])
  @@index([userId, createdAt(sort: Desc)])
  @@map("profile_check_ins")
}

model TierLimit {
  tier             String @id
  memoriesPerDay   Int    @map("memories_per_day")
  memoriesPerMonth Int    @map("memories_per_month")
  imagesPerMonth   Int    @map("images_per_month")
  voicePerMonth    Int    @map("voice_per_month")
  searchesPerDay   Int    @map("searches_per_day")
  storageBytes     BigInt @map("storage_bytes")
  apiRatePerMin    Int    @map("api_rate_per_min")

  @@map("tier_limits")
}

// ============================================================================
// MEMORY TYPE REGISTRY (Admin-controlled)
// ============================================================================

model MemoryType {
  id              String          @id @default(uuid()) @db.Uuid
  code            String          @unique // e.g., "event", "location", "note"
  label           String // Human-readable name
  description     String?
  icon            String?         @default("üìù")
  color           String?         @default("#6B7280")
  storageStrategy StorageStrategy @default(generic) @map("storage_strategy")
  tableName       String?         @map("table_name") // e.g., "events", "locations", null for generic
  enabled         Boolean         @default(true)
  sortOrder       Int             @default(0) @map("sort_order")
  createdAt       DateTime        @default(now()) @map("created_at")
  updatedAt       DateTime        @updatedAt @map("updated_at")

  // Relations
  assignments MemoryTypeAssignment[]

  @@map("memory_types")
}

// ============================================================================
// MEMORY (Root Entity)
// ============================================================================

model Memory {
  id                 String           @id @default(uuid()) @db.Uuid
  userId             String           @map("user_id") @db.Uuid
  title              String?          @db.VarChar(500)
  body               String?          @db.Text
  occurredAt         DateTime?        @map("occurred_at") // When the memory happened
  startAt            DateTime?        @map("start_at") // For events
  endAt              DateTime?        @map("end_at") // For events
  data               Json? // Generic metadata for non-structured types
  latitude           Float?
  longitude          Float?
  imageUrl           String?          @map("image_url")
  state              MemoryState      @default(SAVED)
  contentHash        String?          @map("content_hash") @db.VarChar(32)
  enrichmentStatus   EnrichmentStatus @default(pending) @map("enrichment_status")
  enrichmentQueuedAt DateTime?        @map("enrichment_queued_at")
  locationId         String?          @map("location_id") @db.Uuid
  personId           String?          @map("person_id") @db.Uuid
  youtubeVideoId     String?          @map("youtube_video_id") @db.Uuid
  tiktokVideoId      String?          @map("tiktok_video_id") @db.Uuid
  twitterPostId      String?          @map("twitter_post_id") @db.Uuid

  // Spaced Repetition System (SRS) fields
  lastReviewedAt DateTime? @map("last_reviewed_at")
  nextReviewAt   DateTime? @map("next_review_at")
  reviewInterval Int?      @default(1) @map("review_interval") // Days until next review
  easeFactor     Float?    @default(2.5) @map("ease_factor") // SM-2 algorithm ease factor
  reviewCount    Int       @default(0) @map("review_count")
  lapseCount     Int       @default(0) @map("lapse_count") // Times marked "Again"

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  // Relations
  user            User                   @relation(fields: [userId], references: [id], onDelete: Cascade)
  typeAssignments MemoryTypeAssignment[]
  reminders       Reminder[]
  embeddings      Embedding[]
  idempotencyKeys IdempotencyKey[]
  aiCostTracking  AiCostTracking[]

  // Structured type relations (1:1)
  event Event?

  // Shared entity relations
  location     Location?     @relation(fields: [locationId], references: [id], onDelete: SetNull)
  person       Person?       @relation(fields: [personId], references: [id], onDelete: SetNull)
  youtubeVideo YouTubeVideo? @relation(fields: [youtubeVideoId], references: [id], onDelete: SetNull)
  tiktokVideo  TikTokVideo?  @relation(fields: [tiktokVideoId], references: [id], onDelete: SetNull)
  twitterPost  TwitterPost?  @relation(fields: [twitterPostId], references: [id], onDelete: SetNull)

  // Link relations
  linksFrom       MemoryLink[]         @relation("LinkSource")
  linksTo         MemoryLink[]         @relation("LinkTarget")
  wordLinks       MemoryWordLink[]
  imageLinks      MemoryImageLink[]
  urlPageLinks    MemoryUrlPageLink[]
  projectLinks    MemoryProjectLink[]
  personLinks     MemoryPersonLink[]
  trainingLinks   MemoryTrainingLink[]
  memoryDeckItems MemoryDeckItem[]
  trainingLessons TrainingLesson[]
  questions       Question[]

  @@index([userId, state])
  @@index([userId, contentHash, createdAt])
  @@index([occurredAt])
  @@index([locationId])
  @@index([personId])
  @@index([youtubeVideoId])
  @@index([tiktokVideoId])
  @@index([twitterPostId])
  @@index([userId, nextReviewAt]) // For SRS queries
  @@map("memories")
}

// ============================================================================
// MEMORY TYPE ASSIGNMENT (Many-to-Many)
// ============================================================================

model MemoryTypeAssignment {
  memoryId     String   @map("memory_id") @db.Uuid
  memoryTypeId String   @map("memory_type_id") @db.Uuid
  confidence   Float?   @default(1.0) // AI confidence score
  createdAt    DateTime @default(now()) @map("created_at")
  updatedAt    DateTime @updatedAt @map("updated_at")

  memory     Memory     @relation(fields: [memoryId], references: [id], onDelete: Cascade)
  memoryType MemoryType @relation(fields: [memoryTypeId], references: [id], onDelete: Cascade)

  @@id([memoryId, memoryTypeId])
  @@index([memoryTypeId])
  @@map("memory_type_assignments")
}

// ============================================================================
// STRUCTURED MEMORY TYPES (Dedicated Tables)
// ============================================================================

// Events - structured type
model Event {
  memoryId       String    @id @map("memory_id") @db.Uuid
  startAt        DateTime? @map("start_at")
  endAt          DateTime? @map("end_at")
  timezone       String?   @db.VarChar(50)
  recurrenceRule String?   @map("recurrence_rule") @db.Text
  description    String?   @db.Text
  tags           String[]  @default([])
  lastEnrichedAt DateTime? @map("last_enriched_at")
  createdAt      DateTime  @default(now()) @map("created_at")
  updatedAt      DateTime  @updatedAt @map("updated_at")

  memory Memory @relation(fields: [memoryId], references: [id], onDelete: Cascade)

  @@map("events")
}

// Locations - now a shared/reusable entity
model Location {
  id             String    @id @default(uuid()) @db.Uuid
  name           String    @db.VarChar(200)
  address        String?   @db.Text
  city           String?   @db.VarChar(100)
  state          String?   @db.VarChar(100)
  zip            String?   @db.VarChar(20)
  country        String?   @db.VarChar(100)
  latitude       Float?
  longitude      Float?
  locationType   String?   @map("location_type") @db.VarChar(50)
  placeType      String?   @map("place_type") @db.VarChar(50)
  lastEnrichedAt DateTime? @map("last_enriched_at")
  createdAt      DateTime  @default(now()) @map("created_at")
  updatedAt      DateTime  @updatedAt @map("updated_at")

  memories Memory[]

  @@map("locations")
}

// People - now a shared/reusable entity
model Person {
  id             String    @id @default(uuid()) @db.Uuid
  displayName    String    @map("display_name") @db.VarChar(200)
  email          String?   @db.VarChar(255)
  phone          String?   @db.VarChar(50)
  bio            String?   @db.Text
  lastEnrichedAt DateTime? @map("last_enriched_at")
  createdAt      DateTime  @default(now()) @map("created_at")
  updatedAt      DateTime  @updatedAt @map("updated_at")

  memories          Memory[]
  relationshipsFrom PersonRelationship[]     @relation("RelationshipSource")
  relationshipsTo   PersonRelationship[]     @relation("RelationshipTarget")
  imageLinks        ImagePersonLink[]
  memoryLinks       MemoryPersonLink[]
  urlPageLinks      PersonUrlPageLink[]
  youtubeVideoLinks PersonYouTubeVideoLink[]
  tiktokVideoLinks  PersonTikTokVideoLink[]
  twitterPostLinks  PersonTwitterPostLink[]

  @@map("people")
}

// Person Relationships
model PersonRelationship {
  id               String   @id @default(uuid()) @db.Uuid
  sourcePersonId   String   @map("source_person_id") @db.Uuid
  targetPersonId   String   @map("target_person_id") @db.Uuid
  relationshipType String   @map("relationship_type") @db.VarChar(100)
  createdAt        DateTime @default(now()) @map("created_at")
  updatedAt        DateTime @updatedAt @map("updated_at")

  sourcePerson Person @relation("RelationshipSource", fields: [sourcePersonId], references: [id], onDelete: Cascade)
  targetPerson Person @relation("RelationshipTarget", fields: [targetPersonId], references: [id], onDelete: Cascade)

  @@unique([sourcePersonId, targetPersonId])
  @@index([sourcePersonId])
  @@index([targetPersonId])
  @@map("person_relationships")
}

// Memory-Person Links (Many-to-Many)
model MemoryPersonLink {
  id        String   @id @default(uuid()) @db.Uuid
  memoryId  String   @map("memory_id") @db.Uuid
  personId  String   @map("person_id") @db.Uuid
  createdAt DateTime @default(now()) @map("created_at")

  memory Memory @relation(fields: [memoryId], references: [id], onDelete: Cascade)
  person Person @relation(fields: [personId], references: [id], onDelete: Cascade)

  @@unique([memoryId, personId])
  @@index([memoryId])
  @@index([personId])
  @@map("memory_person_links")
}

// Person-UrlPage Links (Many-to-Many)
model PersonUrlPageLink {
  id        String   @id @default(uuid()) @db.Uuid
  personId  String   @map("person_id") @db.Uuid
  urlPageId String   @map("url_page_id") @db.Uuid
  createdAt DateTime @default(now()) @map("created_at")

  person  Person  @relation(fields: [personId], references: [id], onDelete: Cascade)
  urlPage UrlPage @relation(fields: [urlPageId], references: [id], onDelete: Cascade)

  @@unique([personId, urlPageId])
  @@index([personId])
  @@index([urlPageId])
  @@map("person_url_page_links")
}

// Person-YouTubeVideo Links (Many-to-Many)
model PersonYouTubeVideoLink {
  id             String   @id @default(uuid()) @db.Uuid
  personId       String   @map("person_id") @db.Uuid
  youtubeVideoId String   @map("youtube_video_id") @db.Uuid
  createdAt      DateTime @default(now()) @map("created_at")

  person       Person       @relation(fields: [personId], references: [id], onDelete: Cascade)
  youtubeVideo YouTubeVideo @relation(fields: [youtubeVideoId], references: [id], onDelete: Cascade)

  @@unique([personId, youtubeVideoId])
  @@index([personId])
  @@index([youtubeVideoId])
  @@map("person_youtube_video_links")
}

// Person-TikTokVideo Links (Many-to-Many)
model PersonTikTokVideoLink {
  id            String   @id @default(uuid()) @db.Uuid
  personId      String   @map("person_id") @db.Uuid
  tiktokVideoId String   @map("tiktok_video_id") @db.Uuid
  createdAt     DateTime @default(now()) @map("created_at")

  person      Person      @relation(fields: [personId], references: [id], onDelete: Cascade)
  tiktokVideo TikTokVideo @relation(fields: [tiktokVideoId], references: [id], onDelete: Cascade)

  @@unique([personId, tiktokVideoId])
  @@index([personId])
  @@index([tiktokVideoId])
  @@map("person_tiktok_video_links")
}

// Person-TwitterPost Links (Many-to-Many)
model PersonTwitterPostLink {
  id            String   @id @default(uuid()) @db.Uuid
  personId      String   @map("person_id") @db.Uuid
  twitterPostId String   @map("twitter_post_id") @db.Uuid
  createdAt     DateTime @default(now()) @map("created_at")

  person      Person      @relation(fields: [personId], references: [id], onDelete: Cascade)
  twitterPost TwitterPost @relation(fields: [twitterPostId], references: [id], onDelete: Cascade)

  @@unique([personId, twitterPostId])
  @@index([personId])
  @@index([twitterPostId])
  @@map("person_twitter_post_links")
}

// Words - now a shared/reusable entity (like Location and Person)
model Word {
  id             String    @id @default(uuid()) @db.Uuid
  word           String    @unique @db.VarChar(100)
  description    String?   @db.Text
  phonetic       String?   @db.VarChar(100)
  partOfSpeech   String?   @map("part_of_speech") @db.VarChar(50)
  etymology      String?   @db.Text
  examples       Json? // Array of example sentences
  synonyms       Json? // Array of synonyms
  antonyms       Json? // Array of antonyms
  difficulty     String?   @db.VarChar(20)
  lastEnrichedAt DateTime? @map("last_enriched_at")
  createdAt      DateTime  @default(now()) @map("created_at")
  updatedAt      DateTime  @updatedAt @map("updated_at")

  memoryLinks MemoryWordLink[]

  @@index([word])
  @@map("words")
}

// Questions - user questions answered by AI
model Question {
  id        String   @id @default(uuid()) @db.Uuid
  userId    String   @map("user_id") @db.Uuid
  memoryId  String   @map("memory_id") @db.Uuid
  question  String   @db.Text
  answer    String?  @db.Text
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  memory Memory @relation(fields: [memoryId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([memoryId])
  @@index([userId, createdAt])
  @@map("questions")
}

// Projects - user-specific project organization entity
model Project {
  id          String   @id @default(uuid()) @db.Uuid
  userId      String   @map("user_id") @db.Uuid
  name        String   @db.VarChar(200)
  description String?  @db.Text
  tags        Json?    @default("[]")
  createdAt   DateTime @default(now()) @map("created_at")
  updatedAt   DateTime @updatedAt @map("updated_at")

  user              User                      @relation(fields: [userId], references: [id], onDelete: Cascade)
  memoryLinks       MemoryProjectLink[]
  imageLinks        ProjectImageLink[]
  urlPageLinks      ProjectUrlPageLink[]
  youtubeVideoLinks ProjectYouTubeVideoLink[]
  tiktokVideoLinks  ProjectTikTokVideoLink[]
  twitterPostLinks  ProjectTwitterPostLink[]

  @@index([userId])
  @@index([userId, name])
  @@map("projects")
}

// Memory-Project Links (Many-to-Many)
model MemoryProjectLink {
  id        String   @id @default(uuid()) @db.Uuid
  memoryId  String   @map("memory_id") @db.Uuid
  projectId String   @map("project_id") @db.Uuid
  createdAt DateTime @default(now()) @map("created_at")

  memory  Memory  @relation(fields: [memoryId], references: [id], onDelete: Cascade)
  project Project @relation(fields: [projectId], references: [id], onDelete: Cascade)

  @@unique([memoryId, projectId])
  @@index([memoryId])
  @@index([projectId])
  @@map("memory_project_links")
}

// Project-Image Links (Many-to-Many)
model ProjectImageLink {
  id        String   @id @default(uuid()) @db.Uuid
  projectId String   @map("project_id") @db.Uuid
  imageId   String   @map("image_id") @db.Uuid
  createdAt DateTime @default(now()) @map("created_at")

  project Project @relation(fields: [projectId], references: [id], onDelete: Cascade)
  image   Image   @relation(fields: [imageId], references: [id], onDelete: Cascade)

  @@unique([projectId, imageId])
  @@index([projectId])
  @@index([imageId])
  @@map("project_image_links")
}

// Project-UrlPage Links (Many-to-Many)
model ProjectUrlPageLink {
  id        String   @id @default(uuid()) @db.Uuid
  projectId String   @map("project_id") @db.Uuid
  urlPageId String   @map("url_page_id") @db.Uuid
  createdAt DateTime @default(now()) @map("created_at")

  project Project @relation(fields: [projectId], references: [id], onDelete: Cascade)
  urlPage UrlPage @relation(fields: [urlPageId], references: [id], onDelete: Cascade)

  @@unique([projectId, urlPageId])
  @@index([projectId])
  @@index([urlPageId])
  @@map("project_url_page_links")
}

// Project-YouTubeVideo Links (Many-to-Many)
model ProjectYouTubeVideoLink {
  id             String   @id @default(uuid()) @db.Uuid
  projectId      String   @map("project_id") @db.Uuid
  youtubeVideoId String   @map("youtube_video_id") @db.Uuid
  createdAt      DateTime @default(now()) @map("created_at")

  project      Project      @relation(fields: [projectId], references: [id], onDelete: Cascade)
  youtubeVideo YouTubeVideo @relation(fields: [youtubeVideoId], references: [id], onDelete: Cascade)

  @@unique([projectId, youtubeVideoId])
  @@index([projectId])
  @@index([youtubeVideoId])
  @@map("project_youtube_video_links")
}

// Project-TikTokVideo Links (Many-to-Many)
model ProjectTikTokVideoLink {
  id            String   @id @default(uuid()) @db.Uuid
  projectId     String   @map("project_id") @db.Uuid
  tiktokVideoId String   @map("tiktok_video_id") @db.Uuid
  createdAt     DateTime @default(now()) @map("created_at")

  project     Project     @relation(fields: [projectId], references: [id], onDelete: Cascade)
  tiktokVideo TikTokVideo @relation(fields: [tiktokVideoId], references: [id], onDelete: Cascade)

  @@unique([projectId, tiktokVideoId])
  @@index([projectId])
  @@index([tiktokVideoId])
  @@map("project_tiktok_video_links")
}

// Project-TwitterPost Links (Many-to-Many)
model ProjectTwitterPostLink {
  id            String   @id @default(uuid()) @db.Uuid
  projectId     String   @map("project_id") @db.Uuid
  twitterPostId String   @map("twitter_post_id") @db.Uuid
  createdAt     DateTime @default(now()) @map("created_at")

  project     Project     @relation(fields: [projectId], references: [id], onDelete: Cascade)
  twitterPost TwitterPost @relation(fields: [twitterPostId], references: [id], onDelete: Cascade)

  @@unique([projectId, twitterPostId])
  @@index([projectId])
  @@index([twitterPostId])
  @@map("project_twitter_post_links")
}

// Images - standalone entity for photos/images with face detection
model Image {
  id                String    @id @default(uuid()) @db.Uuid
  userId            String    @map("user_id") @db.Uuid
  storageUrl        String    @map("storage_url") @db.Text
  storageKey        String    @map("storage_key") @db.Text
  thumbnailUrl256   String?   @map("thumbnail_url_256") @db.Text
  thumbnailUrl1024  String?   @map("thumbnail_url_1024") @db.Text
  contentType       String    @map("content_type") @db.VarChar(50)
  sizeBytes         Int       @map("size_bytes")
  sha256            String    @db.VarChar(64)
  phash             String?   @db.VarChar(64)
  width             Int?
  height            Int?
  exifData          Json?     @map("exif_data")
  capturedAt        DateTime? @map("captured_at")
  latitude          Float?
  longitude         Float?
  locationAccuracy  Float?    @map("location_accuracy")
  locationSource    String?   @map("location_source") @db.VarChar(20)
  consentBiometrics Boolean   @default(false) @map("consent_biometrics")
  createdAt         DateTime  @default(now()) @map("created_at")
  updatedAt         DateTime  @updatedAt @map("updated_at")

  user            User                @relation(fields: [userId], references: [id], onDelete: Cascade)
  faces           ImageFace[]
  memoryLinks     MemoryImageLink[]
  personLinks     ImagePersonLink[]
  projectLinks    ProjectImageLink[]
  trainingLinks   TrainingImageLink[]
  trainingLessons TrainingLesson[]

  @@unique([userId, sha256])
  @@index([userId])
  @@index([sha256])
  @@index([phash])
  @@map("images")
}

// Image Faces - detected faces in images
model ImageFace {
  id             String   @id @default(uuid()) @db.Uuid
  imageId        String   @map("image_id") @db.Uuid
  bboxX          Int      @map("bbox_x")
  bboxY          Int      @map("bbox_y")
  bboxWidth      Int      @map("bbox_width")
  bboxHeight     Int      @map("bbox_height")
  blurScore      Float?   @map("blur_score")
  occlusionScore Float?   @map("occlusion_score")
  poseYaw        Float?   @map("pose_yaw")
  posePitch      Float?   @map("pose_pitch")
  poseRoll       Float?   @map("pose_roll")
  embedding      Json? // Face embedding vector (only if consent given)
  embeddingModel String?  @map("embedding_model") @db.VarChar(50)
  faceCropUrl    String?  @map("face_crop_url") @db.Text
  createdAt      DateTime @default(now()) @map("created_at")

  image       Image             @relation(fields: [imageId], references: [id], onDelete: Cascade)
  personLinks ImagePersonLink[]

  @@index([imageId])
  @@map("image_faces")
}

// Image Person Links - links detected faces to people
model ImagePersonLink {
  id         String   @id @default(uuid()) @db.Uuid
  imageId    String   @map("image_id") @db.Uuid
  personId   String   @map("person_id") @db.Uuid
  faceId     String?  @map("face_id") @db.Uuid
  confidence Float? // Match confidence score
  linkMethod String   @map("link_method") @db.VarChar(20) // auto|confirmed|manual
  createdAt  DateTime @default(now()) @map("created_at")

  image  Image      @relation(fields: [imageId], references: [id], onDelete: Cascade)
  person Person     @relation(fields: [personId], references: [id], onDelete: Cascade)
  face   ImageFace? @relation(fields: [faceId], references: [id], onDelete: SetNull)

  @@unique([imageId, personId, faceId])
  @@index([imageId])
  @@index([personId])
  @@index([faceId])
  @@map("image_person_links")
}

// Memory-Image Links (Many-to-Many)
model MemoryImageLink {
  id        String   @id @default(uuid()) @db.Uuid
  memoryId  String   @map("memory_id") @db.Uuid
  imageId   String   @map("image_id") @db.Uuid
  createdAt DateTime @default(now()) @map("created_at")

  memory Memory @relation(fields: [memoryId], references: [id], onDelete: Cascade)
  image  Image  @relation(fields: [imageId], references: [id], onDelete: Cascade)

  @@unique([memoryId, imageId])
  @@index([memoryId])
  @@index([imageId])
  @@map("memory_image_links")
}

// ============================================================================
// URL PAGES - Standalone Entity
// ============================================================================

model UrlPage {
  id          String    @id @default(uuid()) @db.Uuid
  userId      String    @map("user_id") @db.Uuid
  url         String    @db.Text
  urlHash     String    @map("url_hash") @db.VarChar(64) // SHA256 hash for deduplication
  title       String?   @db.Text
  description String?   @db.Text
  summary     String?   @db.Text
  content     String?   @db.Text // Extracted page content
  author      String?   @db.VarChar(255)
  publishedAt DateTime? @map("published_at")
  siteName    String?   @map("site_name") @db.VarChar(255)
  imageUrl    String?   @map("image_url") @db.Text
  tags        Json? // Array of extracted tags
  metadata    Json? // Additional AI-extracted metadata
  fetchedAt   DateTime  @default(now()) @map("fetched_at")
  createdAt   DateTime  @default(now()) @map("created_at")
  updatedAt   DateTime  @updatedAt @map("updated_at")

  user            User                  @relation(fields: [userId], references: [id], onDelete: Cascade)
  memoryLinks     MemoryUrlPageLink[]
  projectLinks    ProjectUrlPageLink[]
  personLinks     PersonUrlPageLink[]
  trainingLinks   TrainingUrlPageLink[]
  trainingLessons TrainingLesson[]

  @@unique([userId, urlHash])
  @@index([userId])
  @@index([urlHash])
  @@index([url])
  @@map("url_pages")
}

model MemoryUrlPageLink {
  id        String   @id @default(uuid()) @db.Uuid
  memoryId  String   @map("memory_id") @db.Uuid
  urlPageId String   @map("url_page_id") @db.Uuid
  createdAt DateTime @default(now()) @map("created_at")

  memory  Memory  @relation(fields: [memoryId], references: [id], onDelete: Cascade)
  urlPage UrlPage @relation(fields: [urlPageId], references: [id], onDelete: Cascade)

  @@unique([memoryId, urlPageId])
  @@index([memoryId])
  @@index([urlPageId])
  @@map("memory_url_page_links")
}

// Excluded Words - words to ignore in spell-check
model ExcludedWord {
  id        String   @id @default(uuid()) @db.Uuid
  userId    String   @map("user_id") @db.Uuid
  word      String   @db.VarChar(100)
  createdAt DateTime @default(now()) @map("created_at")

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, word])
  @@index([userId])
  @@map("excluded_words")
}

// ============================================================================
// CONCEPT MAPPING - AI Keyword Expansion
// ============================================================================

model ConceptMapping {
  id              String   @id @default(uuid()) @db.Uuid
  term            String   @unique @db.VarChar(100)
  normalizedTerm  String   @map("normalized_term") @db.VarChar(100)
  domains         Json // Array of domain strings
  relatedKeywords Json     @map("related_keywords") // Array of keyword strings
  source          String   @db.VarChar(20) // 'static' | 'openai'
  confidence      Float    @default(1.0)
  usageCount      Int      @default(0) @map("usage_count")
  createdAt       DateTime @default(now()) @map("created_at")
  updatedAt       DateTime @updatedAt @map("updated_at")

  @@index([normalizedTerm])
  @@index([source])
  @@map("concept_mappings")
}

// ============================================================================
// YOUTUBE VIDEOS - Shared/Reusable Entity
// ============================================================================

model YouTubeVideo {
  id String @id @default(uuid()) @db.Uuid

  // Platform & YouTube identifiers
  platform       String @default("youtube") @db.VarChar(16)
  youtubeVideoId String @map("youtube_video_id") @db.VarChar(16)
  canonicalUrl   String @map("canonical_url") @db.VarChar(2048)

  // Video metadata
  title        String  @db.VarChar(512)
  description  String? @db.Text
  thumbnailUrl String? @map("thumbnail_url") @db.VarChar(2048)

  // Creator info
  creatorDisplayName String  @map("creator_display_name") @db.VarChar(256)
  channelId          String? @map("channel_id") @db.VarChar(64)

  // Video details
  publishedAt     DateTime @map("published_at")
  durationSeconds Int      @map("duration_seconds")
  languageCode    String   @map("language_code") @db.VarChar(12)

  // Compliance & content details
  license          String?  @db.VarChar(64)
  madeForKids      Boolean? @map("made_for_kids")
  captionAvailable Boolean? @map("caption_available")

  // Transcript data
  transcriptStatus   TranscriptStatus @map("transcript_status")
  transcriptSource   TranscriptSource @map("transcript_source")
  transcriptText     String?          @map("transcript_text") @db.Text
  transcriptSegments Json?            @map("transcript_segments") // Array of {chunk_id, start_seconds, end_seconds, text}

  // Enrichment
  summary  String? @db.Text
  topics   Json? // Array of LLM-derived topics
  chapters Json? // Array of {start_seconds, label, description}

  // Metrics (snapshots)
  viewCount     BigInt?   @map("view_count")
  likeCount     BigInt?   @map("like_count")
  favoriteCount BigInt?   @map("favorite_count")
  commentCount  BigInt?   @map("comment_count")
  categoryId    String?   @map("category_id") @db.VarChar(32)
  capturedAt    DateTime? @map("captured_at") // When statistics were captured

  // Additional metadata
  tags          Json? // Array of tags
  externalLinks Json?   @map("external_links") // Links found in description
  contentHash   String? @map("content_hash") @db.VarChar(64)

  // Ingestion tracking
  ingestionStatus    IngestionStatus @map("ingestion_status")
  ingestionAttempts  Int             @default(0) @map("ingestion_attempts")
  lastIngestionError String?         @map("last_ingestion_error") @db.Text
  ingestedAt         DateTime?       @map("ingested_at")
  lastEnrichedAt     DateTime?       @map("last_enriched_at")

  // Timestamps
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  // Relations
  memories        Memory[]
  projectLinks    ProjectYouTubeVideoLink[]
  personLinks     PersonYouTubeVideoLink[]
  trainingLinks   TrainingYouTubeVideoLink[]
  trainingLessons TrainingLesson[]

  @@unique([platform, youtubeVideoId])
  @@unique([canonicalUrl])
  @@index([channelId])
  @@index([publishedAt(sort: Desc)])
  @@index([ingestedAt(sort: Desc)])
  @@index([languageCode])
  @@index([ingestionStatus])
  @@index([contentHash])
  @@map("youtube_videos")
}

// ============================================================================
// TIKTOK VIDEOS - Shared/Reusable Entity
// ============================================================================

model TikTokVideo {
  id String @id @default(uuid()) @db.Uuid

  // Platform & TikTok identifiers
  platform      String @default("tiktok") @db.VarChar(16)
  tiktokVideoId String @map("tiktok_video_id") @db.VarChar(64)
  canonicalUrl  String @map("canonical_url") @db.VarChar(2048)

  // Video metadata
  title        String  @db.VarChar(512)
  description  String? @db.Text
  thumbnailUrl String? @map("thumbnail_url") @db.VarChar(2048)

  // Creator info
  creatorDisplayName String  @map("creator_display_name") @db.VarChar(256)
  creatorUsername    String? @map("creator_username") @db.VarChar(128)
  creatorId          String? @map("creator_id") @db.VarChar(64)

  // Video details
  publishedAt     DateTime? @map("published_at")
  durationSeconds Int?      @map("duration_seconds")

  // Enrichment
  summary       String? @db.Text
  transcript    String? @db.Text // Whisper transcription of video audio
  extractedData Json?   @map("extracted_data") // Structured data from Whisper analysis
  topics        Json? // Array of LLM-derived topics
  musicInfo     Json?   @map("music_info") // {title, author, url}

  // Metrics (snapshots)
  viewCount    BigInt?   @map("view_count")
  likeCount    BigInt?   @map("like_count")
  shareCount   BigInt?   @map("share_count")
  commentCount BigInt?   @map("comment_count")
  capturedAt   DateTime? @map("captured_at") // When statistics were captured

  // Additional metadata
  hashtags      Json? // Array of hashtags
  mentions      Json? // Array of mentioned users
  externalLinks Json?   @map("external_links") // Links found in description
  contentHash   String? @map("content_hash") @db.VarChar(64)

  // Ingestion tracking
  ingestionStatus    IngestionStatus @map("ingestion_status")
  ingestionAttempts  Int             @default(0) @map("ingestion_attempts")
  lastIngestionError String?         @map("last_ingestion_error") @db.Text
  ingestedAt         DateTime?       @map("ingested_at")
  lastEnrichedAt     DateTime?       @map("last_enriched_at")

  // Timestamps
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  // Relations
  memories        Memory[]
  projectLinks    ProjectTikTokVideoLink[]
  personLinks     PersonTikTokVideoLink[]
  trainingLinks   TrainingTikTokVideoLink[]
  trainingLessons TrainingLesson[]

  @@unique([platform, tiktokVideoId])
  @@unique([canonicalUrl])
  @@index([creatorId])
  @@index([creatorUsername])
  @@index([publishedAt(sort: Desc)])
  @@index([ingestedAt(sort: Desc)])
  @@index([ingestionStatus])
  @@index([contentHash])
  @@map("tiktok_videos")
}

// ============================================================================
// TWITTER/X POSTS - Shared/Reusable Entity
// ============================================================================

model TwitterPost {
  id String @id @default(uuid()) @db.Uuid

  // Platform & Twitter identifiers
  platform      String @default("twitter") @db.VarChar(16)
  twitterPostId String @map("twitter_post_id") @db.VarChar(64)
  canonicalUrl  String @map("canonical_url") @db.VarChar(2048)

  // Post metadata
  text         String  @db.Text
  thumbnailUrl String? @map("thumbnail_url") @db.VarChar(2048)

  // Creator info
  creatorDisplayName String  @map("creator_display_name") @db.VarChar(256)
  creatorUsername    String? @map("creator_username") @db.VarChar(128)
  creatorId          String? @map("creator_id") @db.VarChar(64)

  // Post details
  publishedAt  DateTime @map("published_at")
  languageCode String?  @map("language_code") @db.VarChar(12)

  // Metrics (snapshots)
  viewCount     BigInt?   @map("view_count")
  likeCount     BigInt?   @map("like_count")
  replyCount    BigInt?   @map("reply_count")
  retweetCount  BigInt?   @map("retweet_count")
  quoteCount    BigInt?   @map("quote_count")
  bookmarkCount BigInt?   @map("bookmark_count")
  capturedAt    DateTime? @map("captured_at") // When statistics were captured

  // Media & content
  hasMedia      Boolean @default(false) @map("has_media")
  mediaUrls     Json?   @map("media_urls") // Array of media URLs
  mediaTypes    Json?   @map("media_types") // Array of media types (photo, video, animated_gif)
  hashtags      Json? // Array of hashtags
  mentions      Json? // Array of user mentions
  externalLinks Json?   @map("external_links") // Links found in tweet

  // Enrichment
  summary   String? @db.Text
  topics    Json? // Array of LLM-derived topics
  sentiment String? @db.VarChar(32) // positive, negative, neutral

  // Additional metadata
  isReply     Boolean @default(false) @map("is_reply")
  isRetweet   Boolean @default(false) @map("is_retweet")
  isQuote     Boolean @default(false) @map("is_quote")
  contentHash String? @map("content_hash") @db.VarChar(64)

  // Ingestion tracking
  ingestionStatus    IngestionStatus @map("ingestion_status")
  ingestionAttempts  Int             @default(0) @map("ingestion_attempts")
  lastIngestionError String?         @map("last_ingestion_error") @db.Text
  ingestedAt         DateTime?       @map("ingested_at")
  lastEnrichedAt     DateTime?       @map("last_enriched_at")

  // User association
  userId String @map("user_id") @db.Uuid
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Timestamps
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  // Relations
  memories        Memory[]
  projectLinks    ProjectTwitterPostLink[]
  personLinks     PersonTwitterPostLink[]
  trainingLinks   TrainingTwitterPostLink[]
  trainingLessons TrainingLesson[]

  @@unique([platform, twitterPostId])
  @@unique([canonicalUrl])
  @@index([userId])
  @@index([creatorId])
  @@index([creatorUsername])
  @@index([publishedAt(sort: Desc)])
  @@index([ingestedAt(sort: Desc)])
  @@index([ingestionStatus])
  @@index([contentHash])
  @@map("twitter_posts")
}

// ============================================================================
// MEMORY LINKS (Relationships)
// ============================================================================

model MemoryLink {
  id        String   @id @default(uuid()) @db.Uuid
  sourceId  String   @map("source_id") @db.Uuid
  targetId  String   @map("target_id") @db.Uuid
  linkType  LinkType @map("link_type")
  metadata  Json? // Additional link metadata
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  source Memory @relation("LinkSource", fields: [sourceId], references: [id], onDelete: Cascade)
  target Memory @relation("LinkTarget", fields: [targetId], references: [id], onDelete: Cascade)

  @@unique([sourceId, targetId, linkType])
  @@index([sourceId])
  @@index([targetId])
  @@index([linkType])
  @@map("memory_links")
}

// Memory-Word Links (Many-to-Many)
model MemoryWordLink {
  id        String   @id @default(uuid()) @db.Uuid
  memoryId  String   @map("memory_id") @db.Uuid
  wordId    String   @map("word_id") @db.Uuid
  createdAt DateTime @default(now()) @map("created_at")

  memory Memory @relation(fields: [memoryId], references: [id], onDelete: Cascade)
  word   Word   @relation(fields: [wordId], references: [id], onDelete: Cascade)

  @@unique([memoryId, wordId])
  @@index([memoryId])
  @@index([wordId])
  @@map("memory_word_links")
}

// ============================================================================
// SUPPORTING TABLES
// ============================================================================

model Embedding {
  id           String   @id @default(uuid()) @db.Uuid
  memoryId     String   @map("memory_id") @db.Uuid
  userId       String   @map("user_id") @db.Uuid
  modelVersion String   @default("text-embedding-ada-002") @map("model_version")
  createdAt    DateTime @default(now()) @map("created_at")

  memory Memory @relation(fields: [memoryId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([memoryId])
  @@map("embeddings")
}

model Reminder {
  id          String         @id @default(uuid()) @db.Uuid
  userId      String         @map("user_id") @db.Uuid
  memoryId    String         @map("memory_id") @db.Uuid
  scheduledAt DateTime       @map("scheduled_at")
  sentAt      DateTime?      @map("sent_at")
  status      ReminderStatus @default(pending)
  readAt      DateTime?      @map("read_at")
  dismissedAt DateTime?      @map("dismissed_at")
  createdAt   DateTime       @default(now()) @map("created_at")
  updatedAt   DateTime       @updatedAt @map("updated_at")

  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  memory Memory @relation(fields: [memoryId], references: [id], onDelete: Cascade)

  @@index([userId, status, readAt])
  @@index([userId, status, readAt, dismissedAt])
  @@map("reminders")
}

model Session {
  id               String   @id @default(uuid()) @db.Uuid
  userId           String   @map("user_id") @db.Uuid
  refreshTokenHash String   @map("refresh_token_hash")
  expiresAt        DateTime @map("expires_at")
  createdAt        DateTime @default(now()) @map("created_at")

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([expiresAt])
  @@map("sessions")
}

model IdempotencyKey {
  idempotencyKey String   @id @map("idempotency_key") @db.VarChar(100)
  userId         String   @map("user_id") @db.Uuid
  endpoint       String   @db.VarChar(100)
  requestHash    String?  @map("request_hash") @db.VarChar(64)
  responseStatus Int?     @map("response_status")
  responseBody   Json?    @map("response_body")
  createdAt      DateTime @default(now()) @map("created_at")
  expiresAt      DateTime @map("expires_at")

  user     User    @relation(fields: [userId], references: [id], onDelete: Cascade)
  memory   Memory? @relation(fields: [memoryId], references: [id])
  memoryId String? @map("memory_id") @db.Uuid

  @@index([userId])
  @@index([expiresAt])
  @@map("idempotency_keys")
}

model AiCostTracking {
  id         Int      @id @default(autoincrement())
  date       DateTime @default(now()) @db.Date
  userId     String   @map("user_id") @db.Uuid
  operation  String   @db.VarChar(50)
  tokensUsed Int      @map("tokens_used")
  costCents  Decimal  @map("cost_cents") @db.Decimal(10, 4)
  model      String   @db.VarChar(100)
  memoryId   String?  @map("memory_id") @db.Uuid
  createdAt  DateTime @default(now()) @map("created_at")

  user   User    @relation(fields: [userId], references: [id], onDelete: Cascade)
  memory Memory? @relation(fields: [memoryId], references: [id])

  @@index([date])
  @@index([userId, date])
  @@map("ai_cost_tracking")
}

// ============================================================================
// AUDIT TRAIL
// ============================================================================

model AuditTrail {
  id       String  @id @default(uuid()) @db.Uuid
  tenantId String? @map("tenant_id") @db.Uuid

  // Who: Actor identity
  userId         String? @map("user_id") @db.Uuid
  actorType      String  @default("USER") @map("actor_type") @db.VarChar(20)
  actorEmail     String? @map("actor_email") @db.VarChar(255)
  impersonatorId String? @map("impersonator_id") @db.Uuid

  // What: Event classification
  eventType  String  @map("event_type") @db.VarChar(50)
  action     String  @db.VarChar(20)
  entityName String? @map("entity_name") @db.VarChar(100)
  entityId   String? @map("entity_id") @db.Uuid

  // When: Timing
  createdAt  DateTime @default(now()) @map("created_at")
  durationMs Int?     @map("duration_ms")

  // Where: Request origin
  ipAddress  String? @map("ip_address") @db.VarChar(45)
  userAgent  String? @map("user_agent") @db.Text
  deviceId   String? @map("device_id") @db.VarChar(100)
  geoCountry String? @map("geo_country") @db.VarChar(2)
  geoCity    String? @map("geo_city") @db.VarChar(100)

  // Context: Request tracking
  requestId     String? @map("request_id") @db.VarChar(100)
  sessionId     String? @map("session_id") @db.VarChar(100)
  correlationId String? @map("correlation_id") @db.VarChar(100)
  traceId       String? @map("trace_id") @db.VarChar(100)
  method        String? @db.VarChar(10)
  url           String? @db.VarChar(500)

  // Result: Outcome
  success       Boolean @default(true)
  statusCode    Int?    @map("status_code")
  errorCode     String? @map("error_code") @db.VarChar(50)
  errorMessage  String? @map("error_message") @db.Text
  exceptionType String? @map("exception_type") @db.VarChar(255)

  // Data: State changes and payloads
  beforeJson   Json? @map("before_json")
  afterJson    Json? @map("after_json")
  diffJson     Json? @map("diff_json")
  requestJson  Json? @map("request_json")
  responseJson Json? @map("response_json")

  // Metadata
  loggingLevel    String   @default("STANDARD") @map("logging_level") @db.VarChar(20)
  redactedFields  String[] @map("redacted_fields")
  truncatedFields String[] @map("truncated_fields")
  dataHash        String?  @map("data_hash") @db.VarChar(64)

  // Additional context
  tags  Json?
  notes String? @db.Text
  msg   String? @db.Text

  @@index([userId])
  @@index([createdAt(sort: Desc)])
  @@index([entityName, entityId])
  @@index([requestId])
  @@index([eventType])
  @@index([success, createdAt(sort: Desc)])
  @@index([actorType, createdAt(sort: Desc)])
  @@index([userId, createdAt(sort: Desc)])
  @@map("audit_trail")
}

// ============================================================================
// MEMORY DECKS
// ============================================================================

model MemoryDeck {
  id            String    @id @default(uuid()) @db.Uuid
  userId        String    @map("user_id") @db.Uuid
  title         String?   @db.VarChar(200)
  isArchived    Boolean   @default(false) @map("is_archived")
  autoCreated   Boolean   @default(false) @map("auto_created")
  weekStartDate DateTime? @map("week_start_date")
  createdAt     DateTime  @default(now()) @map("created_at")
  updatedAt     DateTime  @updatedAt @map("updated_at")

  user  User             @relation(fields: [userId], references: [id], onDelete: Cascade)
  items MemoryDeckItem[]

  @@index([userId, createdAt(sort: Desc)])
  @@index([userId, isArchived])
  @@map("memory_decks")
}

model MemoryDeckItem {
  id           String   @id @default(uuid()) @db.Uuid
  memoryDeckId String   @map("memory_deck_id") @db.Uuid
  memoryId     String   @map("memory_id") @db.Uuid
  sortOrder    Int      @map("sort_order")
  createdAt    DateTime @default(now()) @map("created_at")

  memoryDeck MemoryDeck @relation(fields: [memoryDeckId], references: [id], onDelete: Cascade)
  memory     Memory     @relation(fields: [memoryId], references: [id], onDelete: Cascade)

  @@index([memoryDeckId, sortOrder])
  @@index([memoryId])
  @@map("memory_deck_items")
}

// ============================================================================
// TRAINING & TRAINING DECKS
// ============================================================================

// Trainings - user-specific training organization entity
model Training {
  id           String    @id @default(uuid()) @db.Uuid
  userId       String    @map("user_id") @db.Uuid
  name         String    @db.VarChar(200)
  description  String?   @db.Text
  tags         Json?     @default("[]")
  lastViewedAt DateTime? @map("last_viewed_at")
  createdAt    DateTime  @default(now()) @map("created_at")
  updatedAt    DateTime  @updatedAt @map("updated_at")

  user              User                       @relation(fields: [userId], references: [id], onDelete: Cascade)
  memoryLinks       MemoryTrainingLink[]
  imageLinks        TrainingImageLink[]
  urlPageLinks      TrainingUrlPageLink[]
  youtubeVideoLinks TrainingYouTubeVideoLink[]
  tiktokVideoLinks  TrainingTikTokVideoLink[]
  twitterPostLinks  TrainingTwitterPostLink[]
  trainingDecks     TrainingDeck[]

  @@index([userId])
  @@index([userId, name])
  @@map("trainings")
}

// Memory-Training Links (Many-to-Many)
model MemoryTrainingLink {
  id         String   @id @default(uuid()) @db.Uuid
  memoryId   String   @map("memory_id") @db.Uuid
  trainingId String   @map("training_id") @db.Uuid
  createdAt  DateTime @default(now()) @map("created_at")

  memory   Memory   @relation(fields: [memoryId], references: [id], onDelete: Cascade)
  training Training @relation(fields: [trainingId], references: [id], onDelete: Cascade)

  @@unique([memoryId, trainingId])
  @@index([memoryId])
  @@index([trainingId])
  @@map("memory_training_links")
}

// Training-Image Links (Many-to-Many)
model TrainingImageLink {
  id         String   @id @default(uuid()) @db.Uuid
  trainingId String   @map("training_id") @db.Uuid
  imageId    String   @map("image_id") @db.Uuid
  createdAt  DateTime @default(now()) @map("created_at")

  training Training @relation(fields: [trainingId], references: [id], onDelete: Cascade)
  image    Image    @relation(fields: [imageId], references: [id], onDelete: Cascade)

  @@unique([trainingId, imageId])
  @@index([trainingId])
  @@index([imageId])
  @@map("training_image_links")
}

// Training-UrlPage Links (Many-to-Many)
model TrainingUrlPageLink {
  id         String   @id @default(uuid()) @db.Uuid
  trainingId String   @map("training_id") @db.Uuid
  urlPageId  String   @map("url_page_id") @db.Uuid
  createdAt  DateTime @default(now()) @map("created_at")

  training Training @relation(fields: [trainingId], references: [id], onDelete: Cascade)
  urlPage  UrlPage  @relation(fields: [urlPageId], references: [id], onDelete: Cascade)

  @@unique([trainingId, urlPageId])
  @@index([trainingId])
  @@index([urlPageId])
  @@map("training_url_page_links")
}

// Training-YouTubeVideo Links (Many-to-Many)
model TrainingYouTubeVideoLink {
  id             String   @id @default(uuid()) @db.Uuid
  trainingId     String   @map("training_id") @db.Uuid
  youtubeVideoId String   @map("youtube_video_id") @db.Uuid
  createdAt      DateTime @default(now()) @map("created_at")

  training     Training     @relation(fields: [trainingId], references: [id], onDelete: Cascade)
  youtubeVideo YouTubeVideo @relation(fields: [youtubeVideoId], references: [id], onDelete: Cascade)

  @@unique([trainingId, youtubeVideoId])
  @@index([trainingId])
  @@index([youtubeVideoId])
  @@map("training_youtube_video_links")
}

// Training-TikTokVideo Links (Many-to-Many)
model TrainingTikTokVideoLink {
  id            String   @id @default(uuid()) @db.Uuid
  trainingId    String   @map("training_id") @db.Uuid
  tiktokVideoId String   @map("tiktok_video_id") @db.Uuid
  createdAt     DateTime @default(now()) @map("created_at")

  training    Training    @relation(fields: [trainingId], references: [id], onDelete: Cascade)
  tiktokVideo TikTokVideo @relation(fields: [tiktokVideoId], references: [id], onDelete: Cascade)

  @@unique([trainingId, tiktokVideoId])
  @@index([trainingId])
  @@index([tiktokVideoId])
  @@map("training_tiktok_video_links")
}

// Training-TwitterPost Links (Many-to-Many)
model TrainingTwitterPostLink {
  id            String   @id @default(uuid()) @db.Uuid
  trainingId    String   @map("training_id") @db.Uuid
  twitterPostId String   @map("twitter_post_id") @db.Uuid
  createdAt     DateTime @default(now()) @map("created_at")

  training    Training    @relation(fields: [trainingId], references: [id], onDelete: Cascade)
  twitterPost TwitterPost @relation(fields: [twitterPostId], references: [id], onDelete: Cascade)

  @@unique([trainingId, twitterPostId])
  @@index([trainingId])
  @@index([twitterPostId])
  @@map("training_twitter_post_links")
}

// Training Decks - sequential presentation of training content
model TrainingDeck {
  id         String   @id @default(uuid()) @db.Uuid
  userId     String   @map("user_id") @db.Uuid
  trainingId String   @map("training_id") @db.Uuid
  title      String?  @db.VarChar(200)
  createdAt  DateTime @default(now()) @map("created_at")
  updatedAt  DateTime @updatedAt @map("updated_at")

  user            User             @relation(fields: [userId], references: [id], onDelete: Cascade)
  training        Training         @relation(fields: [trainingId], references: [id], onDelete: Cascade)
  trainingLessons TrainingLesson[]

  @@index([userId, createdAt(sort: Desc)])
  @@index([trainingId])
  @@map("training_decks")
}

// Training Lessons - polymorphic content items in a training deck
model TrainingLesson {
  id             String   @id @default(uuid()) @db.Uuid
  trainingDeckId String   @map("training_deck_id") @db.Uuid
  memoryId       String?  @map("memory_id") @db.Uuid
  imageId        String?  @map("image_id") @db.Uuid
  urlPageId      String?  @map("url_page_id") @db.Uuid
  youtubeVideoId String?  @map("youtube_video_id") @db.Uuid
  tiktokVideoId  String?  @map("tiktok_video_id") @db.Uuid
  twitterPostId  String?  @map("twitter_post_id") @db.Uuid
  sortOrder      Int      @map("sort_order")
  createdAt      DateTime @default(now()) @map("created_at")

  trainingDeck TrainingDeck  @relation(fields: [trainingDeckId], references: [id], onDelete: Cascade)
  memory       Memory?       @relation(fields: [memoryId], references: [id], onDelete: Cascade)
  image        Image?        @relation(fields: [imageId], references: [id], onDelete: Cascade)
  urlPage      UrlPage?      @relation(fields: [urlPageId], references: [id], onDelete: Cascade)
  youtubeVideo YouTubeVideo? @relation(fields: [youtubeVideoId], references: [id], onDelete: Cascade)
  tiktokVideo  TikTokVideo?  @relation(fields: [tiktokVideoId], references: [id], onDelete: Cascade)
  twitterPost  TwitterPost?  @relation(fields: [twitterPostId], references: [id], onDelete: Cascade)

  @@index([trainingDeckId, sortOrder])
  @@map("training_lessons")
}

// ============================================================================
// SPEECH-TO-TEXT & TRANSCRIPTION
// ============================================================================

// Speech Sessions - tracks recording sessions (no audio stored)
model SpeechSession {
  id         String              @id @default(uuid()) @db.Uuid
  userId     String              @map("user_id") @db.Uuid
  sessionKey String              @unique @db.VarChar(100) // UUID for WebSocket identification
  status     SpeechSessionStatus @default(active)

  // Audio metadata (no actual audio stored)
  audioFormat String? @db.VarChar(50) // e.g., "audio/webm;codecs=opus"
  durationMs  Int?    @map("duration_ms")
  chunkCount  Int     @default(0) @map("chunk_count")

  // Transcription results
  partialTranscript String? @map("partial_transcript") @db.Text
  finalTranscript   String? @map("final_transcript") @db.Text

  // Processing metadata
  processingStartedAt DateTime? @map("processing_started_at")
  processingEndedAt   DateTime? @map("processing_ended_at")
  errorMessage        String?   @map("error_message") @db.Text

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")
  expiresAt DateTime @map("expires_at") // Auto-cleanup after 1 hour

  user   User          @relation(fields: [userId], references: [id], onDelete: Cascade)
  chunks SpeechChunk[]

  @@index([userId, createdAt(sort: Desc)])
  @@index([sessionKey])
  @@index([expiresAt])
  @@map("speech_sessions")
}

// Speech Chunks - temporary metadata for audio chunks
model SpeechChunk {
  id             String    @id @default(uuid()) @db.Uuid
  sessionId      String    @map("session_id") @db.Uuid
  chunkIndex     Int       @map("chunk_index")
  sizeBytes      Int       @map("size_bytes")
  receivedAt     DateTime  @default(now()) @map("received_at")
  transcribedAt  DateTime? @map("transcribed_at")
  transcriptText String?   @map("transcript_text") @db.Text

  session SpeechSession @relation(fields: [sessionId], references: [id], onDelete: Cascade)

  @@unique([sessionId, chunkIndex])
  @@index([sessionId, chunkIndex])
  @@map("speech_chunks")
}

// User Lexicon - user-specific vocabulary for personalization
model UserLexicon {
  id          String    @id @default(uuid()) @db.Uuid
  userId      String    @map("user_id") @db.Uuid
  term        String    @db.VarChar(200) // The term to recognize (e.g., "Makino")
  replacement String?   @db.VarChar(200) // Optional replacement (null = preserve as-is)
  weight      Float     @default(1.0) // Bias weight for STT provider
  usageCount  Int       @default(0) @map("usage_count") // Times term was applied
  lastUsedAt  DateTime? @map("last_used_at")

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, term])
  @@index([userId])
  @@index([userId, usageCount(sort: Desc)])
  @@map("user_lexicon")
}

// Transcript Feedback - user corrections for learning
model TranscriptFeedback {
  id        String  @id @default(uuid()) @db.Uuid
  userId    String  @map("user_id") @db.Uuid
  sessionId String? @map("session_id") @db.Uuid

  // Before/after text
  rawTranscript String @map("raw_transcript") @db.Text // Original STT output
  correctedText String @map("corrected_text") @db.Text // User-edited version

  // Extracted corrections
  corrections Json // Array of {original: string, corrected: string, type: "term"|"punctuation"|"spelling"}

  // Consent
  consentStore Boolean @default(false) @map("consent_store") // User opted-in to store corrections

  createdAt DateTime @default(now()) @map("created_at")

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, createdAt(sort: Desc)])
  @@index([sessionId])
  @@map("transcript_feedback")
}
